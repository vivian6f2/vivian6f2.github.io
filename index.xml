<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/</link>
    <description>Recent content on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Tap News</title>
      <link>https://vivian6f2.github.io/ec2-34-223-214-115.us-west-2.compute.amazonaws.com3000</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/ec2-34-223-214-115.us-west-2.compute.amazonaws.com3000</guid>
      <description></description>
    </item>
    
    <item>
      <title>Collaborative Online Judge System</title>
      <link>https://vivian6f2.github.io/ec2-54-71-209-134.us-west-2.compute.amazonaws.com3000</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/ec2-54-71-209-134.us-west-2.compute.amazonaws.com3000</guid>
      <description></description>
    </item>
    
    <item>
      <title>Facebook Search Tool</title>
      <link>https://vivian6f2.github.io/project/facebook-search-tool/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/project/facebook-search-tool/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Avalon Board Game</title>
      <link>https://vivian6f2.github.io/project/avalon-boardgame/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/project/avalon-boardgame/</guid>
      <description></description>
    </item>
    
    <item>
      <title>2D Web Side-Scrolling Racing Game</title>
      <link>https://vivian6f2.github.io/project/side-scrolling-racing-game/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/project/side-scrolling-racing-game/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Online Learning System</title>
      <link>https://vivian6f2.github.io/project/online-learning-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/project/online-learning-system/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Face Recognition Roll Call System</title>
      <link>https://vivian6f2.github.io/project/face-recognition-roll-call-system/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/project/face-recognition-roll-call-system/</guid>
      <description></description>
    </item>
    
    <item>
      <title>3 Sum Smaller</title>
      <link>https://vivian6f2.github.io/blog/3-sum-smaller/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/3-sum-smaller/</guid>
      <description>3 Sum Smaller LeetCode #259 
Description Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &amp;lt; target.
For example, given nums = [-2, 0, 1, 3], and target = 2.
Return 2. Because there are two triplets which sums are less than 2:</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-inorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-inorder-traversal/</guid>
      <description>Binary Tree Inorder Traversal LeetCode #94 
Description Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree [1,null,2,3],
return [1,3,2].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Preorder Traversal and Binary Tree Postorder Traversal.
Inorder = left child, current node, right child.
The inorder one is similar to preorder one.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-postorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-postorder-traversal/</guid>
      <description>Binary Tree Postorder Traversal LeetCode #145 
Description Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree {1,#,2,3},
return [3,2,1].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Inorder Traversal and Binary Tree Preorder Traversal.
Postorder = left child, right child, current node.
At first it is hard to figure out how to do it.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-preorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-preorder-traversal/</guid>
      <description>Binary Tree Preorder Traversal LeetCode #144 
Description Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree {1,#,2,3},
return [1,2,3].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Inorder Traversal and Binary Tree Postorder Traversal.
It is always easy to do tree problem recursively. If I want to do it iteratively, then I need a stack to save all tree nodes that I will need later.</description>
    </item>
    
    <item>
      <title>Closest Binary Search Tree Value II</title>
      <link>https://vivian6f2.github.io/blog/closest-binary-search-tree-value-ii/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/closest-binary-search-tree-value-ii/</guid>
      <description>Closest Binary Search Tree Value II LeetCode #272 
Description Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.
Note:
 Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target.</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>https://vivian6f2.github.io/blog/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/copy-list-with-random-pointer/</guid>
      <description>Copy List with Random Pointer LeetCode #138 
Description A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.

My Thoughts Because there is a random pointer for every node, I think it is impossible to copy list with one loop. And I also need to save every node first becuase there is a random pointer, and I am not sure where it is linked to.</description>
    </item>
    
    <item>
      <title>Linked List Cycle II</title>
      <link>https://vivian6f2.github.io/blog/linked-list-cycle-ii/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/linked-list-cycle-ii/</guid>
      <description>Linked List Cycle II LeetCode #142 
Description Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up: Can you solve it without using extra space?

My Thoughts To check if I have already been to a node, I can add a hash map to store every node I gone through. However, if I use a hash map, I need O(n) extra space.</description>
    </item>
    
    <item>
      <title>Remove K Digits</title>
      <link>https://vivian6f2.github.io/blog/remove-k-digits/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/remove-k-digits/</guid>
      <description>Remove K Digits LeetCode #402 
Description Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note:
 The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.  Example 1:
Input: num = &amp;quot;1432219&amp;quot;, k = 3 Output: &amp;quot;1219&amp;quot; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title>Sort Transformed Array</title>
      <link>https://vivian6f2.github.io/blog/sort-transformed-array/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/sort-transformed-array/</guid>
      <description>Sort Transformed Array LeetCode #360 
Description Given a sorted array of integers nums and integer values a, b and c. Apply a function of the form f(x) = ax^2 + bx + c to each element x in the array.
The returned array must be in sorted order.
Expected time complexity: O(n)
Example:
nums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,</description>
    </item>
    
    <item>
      <title>Top K Frequent Elements</title>
      <link>https://vivian6f2.github.io/blog/top-k-frequent-elements/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/top-k-frequent-elements/</guid>
      <description>Top K Frequent Elements LeetCode #347 
Description Given a non-empty array of integers, return the k most frequent elements.
For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].
Note:
 You may assume k is always valid, 1 ? k ? number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.  
My Thoughts I can divide this question into two parts:</description>
    </item>
    
    <item>
      <title>4 Sum</title>
      <link>https://vivian6f2.github.io/blog/4-sum/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/4-sum/</guid>
      <description>4 Sum LeetCode #18 
Description Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note: The solution set must not contain duplicate quadruplets.
For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-level-order-traversal/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-level-order-traversal/</guid>
      <description>Binary Tree Level Order Traversal LeetCode #102 
Description Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For example:
Given binary tree [3,9,20,null,null,15,7],
return its level order traversal as:
[ [3], [9,20], [15,7] ]  
My Thoughts I will try to do this recursively. And I would create a 2-D array with the first dimension for level and second dimension for value.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://vivian6f2.github.io/blog/container-with-most-water/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/container-with-most-water/</guid>
      <description>Container With Most Water LeetCode #11 
Description Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.</description>
    </item>
    
    <item>
      <title>Largest Rectangle in Histogram</title>
      <link>https://vivian6f2.github.io/blog/largest-rectangle-in-histogram/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/largest-rectangle-in-histogram/</guid>
      <description>Largest Rectangle in Histogram LeetCode #84 
Description Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
For example,
Given heights = [2,1,5,6,2,3],
return 10.

My Thoughts At first, this question let me think about Trapping Rain Water. I think I can also do it with two pointers, left and right. And just find pairs of left and right that between them, all the value is not less than left and right.</description>
    </item>
    
    <item>
      <title>Moving Average from Data Stream</title>
      <link>https://vivian6f2.github.io/blog/moving-average-from-data-stream/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/moving-average-from-data-stream/</guid>
      <description>Moving Average from Data Stream LeetCode #346 
Description Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.
For example,
MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3  
My Thoughts For this question, because it is a data stream problem, I would like to do it with queue to make it first-in-first-out.</description>
    </item>
    
    <item>
      <title>Reverse Nodes in k-Group</title>
      <link>https://vivian6f2.github.io/blog/reverse-nodes-in-k-group/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/reverse-nodes-in-k-group/</guid>
      <description>Reverse Nodes in k-Group LeetCode #25 
Description Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.</description>
    </item>
    
    <item>
      <title>Simplify Path</title>
      <link>https://vivian6f2.github.io/blog/simplify-path/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/simplify-path/</guid>
      <description>Simplify Path LeetCode #71 
Description Given an absolute path for a file (Unix-style), simplify it.
For example,
path = &amp;ldquo;/home/&amp;rdquo;, =&amp;gt; &amp;ldquo;/home&amp;rdquo;
path = &amp;ldquo;/a/./b/../../c/&amp;rdquo;, =&amp;gt; &amp;ldquo;/c&amp;rdquo;

My Thoughts I will use stack to solve this problem. And there are some conditions that I will push or pop the stack:
 If I get nothing after &amp;ldquo;/&amp;rdquo;, do nothing. If I get &amp;ldquo;pathname/&amp;rdquo;, push &amp;ldquo;pathname/&amp;rdquo; into stack. If I get &amp;ldquo;.</description>
    </item>
    
    <item>
      <title></title>
      <link>https://vivian6f2.github.io/resume/</link>
      <pubDate>Fri, 11 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/resume/</guid>
      <description>TING-HSUAN (VIVIAN) LIN Los Angeles, CA 90007 | 714-332-7325 | tinghsul@usc.edu | https://www.linkedin.com/in/ting-hsuan-lin-829138133 | https://vivian6f2.github.io
Download PDF
EDUCATION University of Southern California, Los Angeles, CA 2016-2018 Master of Science, Computer Science (GPA:3.75&amp;frasl;4.0)
Course Highlights: 3-D Graphics and Rendering, Web Technologies, Database Systems
National Chiao Tung University, Hsinchu, Taiwan 2012-2016 Bachelor of Science, Computer Science (GPA:3.95&amp;frasl;4.0)
Course Highlights: Human-Computer Interaction, Internet of Things, Microprocessor System, Computer Graphics, Hardware-Software Co-design
TECHNICAL SKILLS Programming Languages (order by familiarity): C++, Java, Python, C, JavaScript, PHP, MySQL, HTML, Matlab, CSS, Swift, Assembly, Verilog</description>
    </item>
    
    <item>
      <title>About This Website</title>
      <link>https://vivian6f2.github.io/blog/about-this-website/</link>
      <pubDate>Fri, 11 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/about-this-website/</guid>
      <description>About This Website 
This website is built based on hugo with theme minimal.
I built this website for displaying my projects and resume, and also for updating blog in a flexible, easy-to-use static site.
If you are interested, feel free to take a look at github.</description>
    </item>
    
    <item>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</guid>
      <description>Convert Sorted Array to Binary Search Tree LeetCode #108 
Description Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 
My Thoughts I like to do tree problem recursively if I can. And for this problem, I know I can do it recursively by dividing a big problem into two small problems until I can solve the question.
Because I have to convert array to a height balanced BST, I think that I have to divide the array in the middle everytime.</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>https://vivian6f2.github.io/blog/merge-two-binary-trees/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/merge-two-binary-trees/</guid>
      <description>Merge Two Binary Trees LeetCode #617 
Description Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.</description>
    </item>
    
    <item>
      <title>What Happens When Typing URL Into The Browser</title>
      <link>https://vivian6f2.github.io/blog/what-happens-when-typing-url-into-the-browser/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/what-happens-when-typing-url-into-the-browser/</guid>
      <description>What Happens When Typing URL Into The Browser 
Description What happens when you type www.google.com into the browser? Outline the &amp;ldquo;life of a request&amp;rdquo; from beginning to end.

My Answer High-level outline  Browser check it&amp;rsquo;s cache to see if it has been to that domain name before.
After user typed www.google.com in browser&amp;rsquo;s url bar and clicked enter, browser will check the input with the domain IP pair in it&amp;rsquo;s cache.</description>
    </item>
    
    <item>
      <title>3 Sum</title>
      <link>https://vivian6f2.github.io/blog/3-sum/</link>
      <pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/3-sum/</guid>
      <description>3 Sum LeetCode #15 
Description Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

My Thoughts Create a helper function twoSum(nums, target), to find if there are any two elements A and B in nums, A + B = target.</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>https://vivian6f2.github.io/blog/longest-substring-without-repeating-characters/</link>
      <pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/longest-substring-without-repeating-characters/</guid>
      <description>Longest Substring Without Repeating Characters LeetCode #3 
Description Given a string, find the length of the longest substring without repeating characters.
Examples:
Given &amp;ldquo;abcabcbb&amp;rdquo;, the answer is &amp;ldquo;abc&amp;rdquo;, which the length is 3.
Given &amp;ldquo;bbbbb&amp;rdquo;, the answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.
Given &amp;ldquo;pwwkew&amp;rdquo;, the answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3. Note that the answer must be a substring, &amp;ldquo;pwke&amp;rdquo; is a subsequence and not a substring.</description>
    </item>
    
    <item>
      <title>How Many Combination Results</title>
      <link>https://vivian6f2.github.io/blog/how-many-combination-results/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/how-many-combination-results/</guid>
      <description>How Many Combination Results 
Description Given an array of numbers, put [+, -, *, /] randomly between every two numbers. Compute and list all possible results.

My Thoughts I think I can do it both iteratively and recursively. If I want to do it iteratively, then I need a stack or a queue. While I do it recursively, then I just have to push result into array when I finish computing last number.</description>
    </item>
    
    <item>
      <title>Reorder List</title>
      <link>https://vivian6f2.github.io/blog/reorder-list/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/reorder-list/</guid>
      <description>Reorder List LeetCode #143 
Description Given a singly linked list L: L0?L1?…?Ln-1?Ln, reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?…
You must do this in-place without altering the nodes&amp;rsquo; values.
For example, Given {1,2,3,4}, reorder it to {1,4,2,3}. 
My Thoughts I will divide this question into some smaller questions:
 Find the middle of the linked list. Just use two pointers, slow and fast. Slow pointer takes one step everytime while fast pointer takes two step.</description>
    </item>
    
    <item>
      <title>Trapping Rain Water</title>
      <link>https://vivian6f2.github.io/blog/trapping-rain-water/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/trapping-rain-water/</guid>
      <description>Trapping Rain Water LeetCode #42 
Description Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
For example,  Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.
My Thoughts I would like to do this problem with two pointers, one points to left wall and another to right wall. If I can find out left and right wall for every part that can trap water, then I can easily compute total water I can get.</description>
    </item>
    
  </channel>
</rss>