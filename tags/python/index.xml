<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/python/</link>
    <description>Recent content in Python on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Collaborative Online Judge System</title>
      <link>https://vivian6f2.github.io/ec2-54-71-209-134.us-west-2.compute.amazonaws.com3000</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/ec2-54-71-209-134.us-west-2.compute.amazonaws.com3000</guid>
      <description></description>
    </item>
    
    <item>
      <title>Tap News</title>
      <link>https://vivian6f2.github.io/ec2-34-223-214-115.us-west-2.compute.amazonaws.com3000</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/ec2-34-223-214-115.us-west-2.compute.amazonaws.com3000</guid>
      <description></description>
    </item>
    
    <item>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</guid>
      <description>Convert Sorted Array to Binary Search Tree LeetCode #108 
Description Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 
My Thoughts I like to do tree problem recursively if I can. And for this problem, I know I can do it recursively by dividing a big problem into two small problems until I can solve the question.
Because I have to convert array to a height balanced BST, I think that I have to divide the array in the middle everytime.</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>https://vivian6f2.github.io/blog/merge-two-binary-trees/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/merge-two-binary-trees/</guid>
      <description>Merge Two Binary Trees LeetCode #617 
Description Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.</description>
    </item>
    
    <item>
      <title>How Many Combination Results</title>
      <link>https://vivian6f2.github.io/blog/how-many-combination-results/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/how-many-combination-results/</guid>
      <description>How Many Combination Results 
Description Given an array of numbers, put [+, -, *, /] randomly between every two numbers. Compute and list all possible results.

My Thoughts I think I can do it both iteratively and recursively. If I want to do it iteratively, then I need a stack or a queue. While I do it recursively, then I just have to push result into array when I finish computing last number.</description>
    </item>
    
    <item>
      <title>Trapping Rain Water</title>
      <link>https://vivian6f2.github.io/blog/trapping-rain-water/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/trapping-rain-water/</guid>
      <description>Trapping Rain Water LeetCode #42 
Description Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
For example,  Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.
My Thoughts I would like to do this problem with two pointers, one points to left wall and another to right wall. If I can find out left and right wall for every part that can trap water, then I can easily compute total water I can get.</description>
    </item>
    
  </channel>
</rss>