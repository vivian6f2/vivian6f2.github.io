<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/python/</link>
    <description>Recent content in Python on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Collaborative Online Judge System</title>
      <link>https://vivian6f2.github.io/ec2-54-71-209-134.us-west-2.compute.amazonaws.com3000</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/ec2-54-71-209-134.us-west-2.compute.amazonaws.com3000</guid>
      <description></description>
    </item>
    
    <item>
      <title>Tap News</title>
      <link>https://vivian6f2.github.io/ec2-34-223-214-115.us-west-2.compute.amazonaws.com3000</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/ec2-34-223-214-115.us-west-2.compute.amazonaws.com3000</guid>
      <description></description>
    </item>
    
    <item>
      <title>Moving Average from Data Stream</title>
      <link>https://vivian6f2.github.io/blog/moving-average-from-data-stream/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/moving-average-from-data-stream/</guid>
      <description>Moving Average from Data Stream LeetCode #346 
Description Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.
For example,
MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3  
My Thoughts For this question, because it is a data stream problem, I would like to do it with queue to make it first-in-first-out.</description>
    </item>
    
    <item>
      <title>Reverse Nodes in k-Group</title>
      <link>https://vivian6f2.github.io/blog/reverse-nodes-in-k-group/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/reverse-nodes-in-k-group/</guid>
      <description>Reverse Nodes in k-Group LeetCode #25 
Description Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.</description>
    </item>
    
    <item>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</guid>
      <description>Convert Sorted Array to Binary Search Tree LeetCode #108 
Description Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 
My Thoughts I like to do tree problem recursively if I can. And for this problem, I know I can do it recursively by dividing a big problem into two small problems until I can solve the question.
Because I have to convert array to a height balanced BST, I think that I have to divide the array in the middle everytime.</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>https://vivian6f2.github.io/blog/merge-two-binary-trees/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/merge-two-binary-trees/</guid>
      <description>Merge Two Binary Trees LeetCode #617 
Description Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.</description>
    </item>
    
    <item>
      <title>How Many Combination Results</title>
      <link>https://vivian6f2.github.io/blog/how-many-combination-results/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/how-many-combination-results/</guid>
      <description>How Many Combination Results 
Description Given an array of numbers, put [+, -, *, /] randomly between every two numbers. Compute and list all possible results.

My Thoughts I think I can do it both iteratively and recursively. If I want to do it iteratively, then I need a stack or a queue. While I do it recursively, then I just have to push result into array when I finish computing last number.</description>
    </item>
    
    <item>
      <title>Trapping Rain Water</title>
      <link>https://vivian6f2.github.io/blog/trapping-rain-water/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/trapping-rain-water/</guid>
      <description>Trapping Rain Water LeetCode #42 
Description Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
For example,  Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.
My Thoughts I would like to do this problem with two pointers, one points to left wall and another to right wall. If I can find out left and right wall for every part that can trap water, then I can easily compute total water I can get.</description>
    </item>
    
  </channel>
</rss>