<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/python/</link>
    <description>Recent content in Python on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Collaborative Online Judge System</title>
      <link>https://vivian6f2.github.io/ec2-54-71-209-134.us-west-2.compute.amazonaws.com3000</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/ec2-54-71-209-134.us-west-2.compute.amazonaws.com3000</guid>
      <description></description>
    </item>
    
    <item>
      <title>Tap News</title>
      <link>https://vivian6f2.github.io/ec2-34-223-214-115.us-west-2.compute.amazonaws.com3000</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/ec2-34-223-214-115.us-west-2.compute.amazonaws.com3000</guid>
      <description></description>
    </item>
    
    <item>
      <title>Path Sum</title>
      <link>https://vivian6f2.github.io/blog/path-sum/</link>
      <pubDate>Sun, 27 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/path-sum/</guid>
      <description>Path Sum LeetCode #112 
Description Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
For example:
Given the below binary tree and sum = 22,
 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1  return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>Path Sum II</title>
      <link>https://vivian6f2.github.io/blog/path-sum-ii/</link>
      <pubDate>Sun, 27 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/path-sum-ii/</guid>
      <description>Path Sum II LeetCode #113 
Description Given a binary tree and a sum, find all root-to-leaf paths where each path&amp;rsquo;s sum equals the given sum.
For example:
Given the below binary tree and sum = 22,
 5 / \ 4 8 / / \ 11 13 4 / \ / \ 7 2 5 1  return
[ [5,4,11,2], [5,8,4,5] ]  
My Thoughts It is similar to Path Sum problem.</description>
    </item>
    
    <item>
      <title>Path Sum IV</title>
      <link>https://vivian6f2.github.io/blog/path-sum-iv/</link>
      <pubDate>Sun, 27 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/path-sum-iv/</guid>
      <description>Path Sum IV LeetCode #666 
Description If the depth of a tree is smaller than 5, then this tree can be represented by a list of three-digits integers.
For each integer in this list:
1 The hundreds digit represents the depth D of this node, 1 &amp;lt;= D &amp;lt;= 4. 2 The tens digit represents the position P of this node in the level it belongs to, 1 &amp;lt;= P &amp;lt;= 8.</description>
    </item>
    
    <item>
      <title>Binary Tree Zigzag Level Order Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Sat, 26 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-zigzag-level-order-traversal/</guid>
      <description>Binary Tree Zigzag Level Order Traversal LeetCode #103 
Description Given a binary tree, return the zigzag level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, then right to left for the next level and alternate between).
For example:
Given binary tree [3,9,20,null,null,15,7],
 3 / \ 9 20 / \ 15 7  return its zigzag level order traversal as:
[ [3], [20,9], [15,7] ]</description>
    </item>
    
    <item>
      <title>Search in Rotated Sorted Array</title>
      <link>https://vivian6f2.github.io/blog/search-in-rotated-sorted-array/</link>
      <pubDate>Sat, 26 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/search-in-rotated-sorted-array/</guid>
      <description>Search in Rotated Sorted Array LeetCode #33 
Description Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.
(i.e., 0 1 2 4 5 6 7 might become 4 5 6 7 0 1 2).
You are given a target value to search. If found in the array return its index, otherwise return -1.
You may assume no duplicate exists in the array.</description>
    </item>
    
    <item>
      <title>Spiral Matrix</title>
      <link>https://vivian6f2.github.io/blog/spiral-matrix/</link>
      <pubDate>Sat, 26 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/spiral-matrix/</guid>
      <description>Spiral Matrix LeetCode #54 
Description Given a matrix of m x n elements (m rows, n columns), return all elements of the matrix in spiral order.
For example,
Given the following matrix:
[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]  You should return [1,2,3,6,9,8,7,4,5].

My Thoughts At first, I think about using a pointer to do that. So at first it goes right and until the next point does not exist, it changes its direction.</description>
    </item>
    
    <item>
      <title>Spiral Matrix II</title>
      <link>https://vivian6f2.github.io/blog/spiral-matrix-ii/</link>
      <pubDate>Sat, 26 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/spiral-matrix-ii/</guid>
      <description>Spiral Matrix II LeetCode #59 
Description Given an integer n, generate a square matrix filled with elements from 1 to n^2 in spiral order.
For example,
Given n = 3,
You should return the following matrix:
[ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]  
My Thoughts This is similar to Spiral Matrix. So I would like to solve this problem recursively too.</description>
    </item>
    
    <item>
      <title>Gas Station</title>
      <link>https://vivian6f2.github.io/blog/gas-station/</link>
      <pubDate>Fri, 25 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/gas-station/</guid>
      <description>Gas Station LeetCode #134 
Description There are N gas stations along a circular route, where the amount of gas at station i is gas[i].
You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
Return the starting gas station&amp;rsquo;s index if you can travel around the circuit once, otherwise return -1.</description>
    </item>
    
    <item>
      <title>3 Sum Smaller</title>
      <link>https://vivian6f2.github.io/blog/3-sum-smaller/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/3-sum-smaller/</guid>
      <description>3 Sum Smaller LeetCode #259 
Description Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &amp;lt; target.
For example, given nums = [-2, 0, 1, 3], and target = 2.
Return 2. Because there are two triplets which sums are less than 2:</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-inorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-inorder-traversal/</guid>
      <description>Binary Tree Inorder Traversal LeetCode #94 
Description Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree [1,null,2,3],
return [1,3,2].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Preorder Traversal and Binary Tree Postorder Traversal.
Inorder = left child, current node, right child.
The inorder one is similar to preorder one.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-postorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-postorder-traversal/</guid>
      <description>Binary Tree Postorder Traversal LeetCode #145 
Description Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree {1,#,2,3},
return [3,2,1].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Inorder Traversal and Binary Tree Preorder Traversal.
Postorder = left child, right child, current node.
At first it is hard to figure out how to do it.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-preorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-preorder-traversal/</guid>
      <description>Binary Tree Preorder Traversal LeetCode #144 
Description Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree {1,#,2,3},
return [1,2,3].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Inorder Traversal and Binary Tree Postorder Traversal.
It is always easy to do tree problem recursively. If I want to do it iteratively, then I need a stack to save all tree nodes that I will need later.</description>
    </item>
    
    <item>
      <title>Closest Binary Search Tree Value II</title>
      <link>https://vivian6f2.github.io/blog/closest-binary-search-tree-value-ii/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/closest-binary-search-tree-value-ii/</guid>
      <description>Closest Binary Search Tree Value II LeetCode #272 
Description Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.
Note:
 Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target.</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>https://vivian6f2.github.io/blog/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/copy-list-with-random-pointer/</guid>
      <description>Copy List with Random Pointer LeetCode #138 
Description A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.

My Thoughts Because there is a random pointer for every node, I think it is impossible to copy list with one loop. And I also need to save every node first becuase there is a random pointer, and I am not sure where it is linked to.</description>
    </item>
    
    <item>
      <title>Linked List Cycle II</title>
      <link>https://vivian6f2.github.io/blog/linked-list-cycle-ii/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/linked-list-cycle-ii/</guid>
      <description>Linked List Cycle II LeetCode #142 
Description Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up: Can you solve it without using extra space?

My Thoughts To check if I have already been to a node, I can add a hash map to store every node I gone through. However, if I use a hash map, I need O(n) extra space.</description>
    </item>
    
    <item>
      <title>Remove K Digits</title>
      <link>https://vivian6f2.github.io/blog/remove-k-digits/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/remove-k-digits/</guid>
      <description>Remove K Digits LeetCode #402 
Description Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note:
 The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.  Example 1:
Input: num = &amp;quot;1432219&amp;quot;, k = 3 Output: &amp;quot;1219&amp;quot; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title>Sort Transformed Array</title>
      <link>https://vivian6f2.github.io/blog/sort-transformed-array/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/sort-transformed-array/</guid>
      <description>Sort Transformed Array LeetCode #360 
Description Given a sorted array of integers nums and integer values a, b and c. Apply a function of the form f(x) = ax^2 + bx + c to each element x in the array.
The returned array must be in sorted order.
Expected time complexity: O(n)
Example:
nums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,</description>
    </item>
    
    <item>
      <title>Top K Frequent Elements</title>
      <link>https://vivian6f2.github.io/blog/top-k-frequent-elements/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/top-k-frequent-elements/</guid>
      <description>Top K Frequent Elements LeetCode #347 
Description Given a non-empty array of integers, return the k most frequent elements.
For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].
Note:
 You may assume k is always valid, 1 ? k ? number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.  
My Thoughts I can divide this question into two parts:</description>
    </item>
    
    <item>
      <title>4 Sum</title>
      <link>https://vivian6f2.github.io/blog/4-sum/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/4-sum/</guid>
      <description>4 Sum LeetCode #18 
Description Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note: The solution set must not contain duplicate quadruplets.
For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://vivian6f2.github.io/blog/container-with-most-water/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/container-with-most-water/</guid>
      <description>Container With Most Water LeetCode #11 
Description Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.</description>
    </item>
    
    <item>
      <title>Largest Rectangle in Histogram</title>
      <link>https://vivian6f2.github.io/blog/largest-rectangle-in-histogram/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/largest-rectangle-in-histogram/</guid>
      <description>Largest Rectangle in Histogram LeetCode #84 
Description Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
For example,
Given heights = [2,1,5,6,2,3],
return 10.

My Thoughts At first, this question let me think about Trapping Rain Water. I think I can also do it with two pointers, left and right. And just find pairs of left and right that between them, all the value is not less than left and right.</description>
    </item>
    
    <item>
      <title>Moving Average from Data Stream</title>
      <link>https://vivian6f2.github.io/blog/moving-average-from-data-stream/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/moving-average-from-data-stream/</guid>
      <description>Moving Average from Data Stream LeetCode #346 
Description Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.
For example,
MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3  
My Thoughts For this question, because it is a data stream problem, I would like to do it with queue to make it first-in-first-out.</description>
    </item>
    
    <item>
      <title>Reverse Nodes in k-Group</title>
      <link>https://vivian6f2.github.io/blog/reverse-nodes-in-k-group/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/reverse-nodes-in-k-group/</guid>
      <description>Reverse Nodes in k-Group LeetCode #25 
Description Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.</description>
    </item>
    
    <item>
      <title>Simplify Path</title>
      <link>https://vivian6f2.github.io/blog/simplify-path/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/simplify-path/</guid>
      <description>Simplify Path LeetCode #71 
Description Given an absolute path for a file (Unix-style), simplify it.
For example,
path = &amp;ldquo;/home/&amp;rdquo;, =&amp;gt; &amp;ldquo;/home&amp;rdquo;
path = &amp;ldquo;/a/./b/../../c/&amp;rdquo;, =&amp;gt; &amp;ldquo;/c&amp;rdquo;

My Thoughts I will use stack to solve this problem. And there are some conditions that I will push or pop the stack:
 If I get nothing after &amp;ldquo;/&amp;rdquo;, do nothing. If I get &amp;ldquo;pathname/&amp;rdquo;, push &amp;ldquo;pathname/&amp;rdquo; into stack. If I get &amp;ldquo;.</description>
    </item>
    
    <item>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</guid>
      <description>Convert Sorted Array to Binary Search Tree LeetCode #108 
Description Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 
My Thoughts I like to do tree problem recursively if I can. And for this problem, I know I can do it recursively by dividing a big problem into two small problems until I can solve the question.
Because I have to convert array to a height balanced BST, I think that I have to divide the array in the middle everytime.</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>https://vivian6f2.github.io/blog/merge-two-binary-trees/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/merge-two-binary-trees/</guid>
      <description>Merge Two Binary Trees LeetCode #617 
Description Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.</description>
    </item>
    
    <item>
      <title>How Many Combination Results</title>
      <link>https://vivian6f2.github.io/blog/how-many-combination-results/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/how-many-combination-results/</guid>
      <description>How Many Combination Results 
Description Given an array of numbers, put [+, -, *, /] randomly between every two numbers. Compute and list all possible results.

My Thoughts I think I can do it both iteratively and recursively. If I want to do it iteratively, then I need a stack or a queue. While I do it recursively, then I just have to push result into array when I finish computing last number.</description>
    </item>
    
    <item>
      <title>Trapping Rain Water</title>
      <link>https://vivian6f2.github.io/blog/trapping-rain-water/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/trapping-rain-water/</guid>
      <description>Trapping Rain Water LeetCode #42 
Description Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
For example,  Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.
My Thoughts I would like to do this problem with two pointers, one points to left wall and another to right wall. If I can find out left and right wall for every part that can trap water, then I can easily compute total water I can get.</description>
    </item>
    
  </channel>
</rss>