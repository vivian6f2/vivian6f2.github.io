<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hash Table on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/hash-table/</link>
    <description>Recent content in Hash Table on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/hash-table/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Minimum Window Substring</title>
      <link>https://vivian6f2.github.io/blog/minimum-window-substring/</link>
      <pubDate>Mon, 25 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/minimum-window-substring/</guid>
      <description>Minimum Window Substring LeetCode #76 
Description Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
For example,
S = &amp;ldquo;ADOBECODEBANC&amp;rdquo;
T = &amp;ldquo;ABC&amp;rdquo;
Minimum window is &amp;ldquo;BANC&amp;rdquo;.

My Thoughts I need two dictionaries and two sets to solve this problem. One dictionary count how many times a character appears in target string, and one set store all the unique characters shown in target string.</description>
    </item>
    
    <item>
      <title>Isomorphic Strings</title>
      <link>https://vivian6f2.github.io/blog/isomorphic-strings/</link>
      <pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/isomorphic-strings/</guid>
      <description>Isomorphic Strings LeetCode #205 
Description Given two strings s and t, determine if they are isomorphic.
Two strings are isomorphic if the characters in s can be replaced to get t.
All occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character but a character may map to itself.
For example,
Given &amp;ldquo;egg&amp;rdquo;, &amp;ldquo;add&amp;rdquo;, return true.</description>
    </item>
    
    <item>
      <title>Word Abbreviation</title>
      <link>https://vivian6f2.github.io/blog/word-abbreviation/</link>
      <pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/word-abbreviation/</guid>
      <description>Word Abbreviation LeetCode #527 
Description Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below.
 Begin with the first character and then the number of characters abbreviated, which followed by the last character. If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique.</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>https://vivian6f2.github.io/blog/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/copy-list-with-random-pointer/</guid>
      <description>Copy List with Random Pointer LeetCode #138 
Description A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.

My Thoughts Because there is a random pointer for every node, I think it is impossible to copy list with one loop. And I also need to save every node first becuase there is a random pointer, and I am not sure where it is linked to.</description>
    </item>
    
    <item>
      <title>Top K Frequent Elements</title>
      <link>https://vivian6f2.github.io/blog/top-k-frequent-elements/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/top-k-frequent-elements/</guid>
      <description>Top K Frequent Elements LeetCode #347 
Description Given a non-empty array of integers, return the k most frequent elements.
For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].
Note:
 You may assume k is always valid, 1 ? k ? number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.  
My Thoughts I can divide this question into two parts:</description>
    </item>
    
    <item>
      <title>4 Sum</title>
      <link>https://vivian6f2.github.io/blog/4-sum/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/4-sum/</guid>
      <description>4 Sum LeetCode #18 
Description Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note: The solution set must not contain duplicate quadruplets.
For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</description>
    </item>
    
  </channel>
</rss>