<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>String on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/string/</link>
    <description>Recent content in String on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 25 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/string/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Minimum Window Substring</title>
      <link>https://vivian6f2.github.io/blog/minimum-window-substring/</link>
      <pubDate>Mon, 25 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/minimum-window-substring/</guid>
      <description>Minimum Window Substring LeetCode #76 
Description Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
For example,
S = &amp;ldquo;ADOBECODEBANC&amp;rdquo;
T = &amp;ldquo;ABC&amp;rdquo;
Minimum window is &amp;ldquo;BANC&amp;rdquo;.

My Thoughts I need two dictionaries and two sets to solve this problem. One dictionary count how many times a character appears in target string, and one set store all the unique characters shown in target string.</description>
    </item>
    
    <item>
      <title>Palindromic Substrings</title>
      <link>https://vivian6f2.github.io/blog/palindromic-substrings/</link>
      <pubDate>Mon, 25 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/palindromic-substrings/</guid>
      <description>Palindromic Substrings LeetCode #647 
Description Given a string, your task is to count how many palindromic substrings in this string.
The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
Example 1:
Input: &amp;quot;abc&amp;quot; Output: 3 Explanation: Three palindromic strings: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;.  Example 2:
Input: &amp;quot;aaa&amp;quot; Output: 6 Explanation: Six palindromic strings: &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aa&amp;quot;, &amp;quot;aaa&amp;quot;.</description>
    </item>
    
    <item>
      <title>Decode Ways</title>
      <link>https://vivian6f2.github.io/blog/decode-ways/</link>
      <pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/decode-ways/</guid>
      <description>Decode Ways LeetCode #91 
Description A message containing letters from A-Z is being encoded to numbers using the following mapping:
&#39;A&#39; -&amp;gt; 1 &#39;B&#39; -&amp;gt; 2 ... &#39;Z&#39; -&amp;gt; 26  Given an encoded message containing digits, determine the total number of ways to decode it.
For example,
Given encoded message &amp;ldquo;12&amp;rdquo;, it could be decoded as &amp;ldquo;AB&amp;rdquo; (1 2) or &amp;ldquo;L&amp;rdquo; (12).
The number of ways decoding &amp;ldquo;12&amp;rdquo; is 2.</description>
    </item>
    
    <item>
      <title>Valid Word Abbreviation</title>
      <link>https://vivian6f2.github.io/blog/valid-word-abbreviation/</link>
      <pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/valid-word-abbreviation/</guid>
      <description>Valid Word Abbreviation LeetCode #408 
Description Given a non-empty string s and an abbreviation abbr, return whether the string matches with the given abbreviation.
A string such as &amp;ldquo;word&amp;rdquo; contains only the following valid abbreviations:
[&amp;quot;word&amp;quot;, &amp;quot;1ord&amp;quot;, &amp;quot;w1rd&amp;quot;, &amp;quot;wo1d&amp;quot;, &amp;quot;wor1&amp;quot;, &amp;quot;2rd&amp;quot;, &amp;quot;w2d&amp;quot;, &amp;quot;wo2&amp;quot;, &amp;quot;1o1d&amp;quot;, &amp;quot;1or1&amp;quot;, &amp;quot;w1r1&amp;quot;, &amp;quot;1o2&amp;quot;, &amp;quot;2r1&amp;quot;, &amp;quot;3d&amp;quot;, &amp;quot;w3&amp;quot;, &amp;quot;4&amp;quot;]  Notice that only the above abbreviations are valid abbreviations of the string &amp;ldquo;word&amp;rdquo;. Any other string is not a valid abbreviation of &amp;ldquo;word&amp;rdquo;.</description>
    </item>
    
    <item>
      <title>Word Abbreviation</title>
      <link>https://vivian6f2.github.io/blog/word-abbreviation/</link>
      <pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/word-abbreviation/</guid>
      <description>Word Abbreviation LeetCode #527 
Description Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below.
 Begin with the first character and then the number of characters abbreviated, which followed by the last character. If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique.</description>
    </item>
    
    <item>
      <title>Simplify Path</title>
      <link>https://vivian6f2.github.io/blog/simplify-path/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/simplify-path/</guid>
      <description>Simplify Path LeetCode #71 
Description Given an absolute path for a file (Unix-style), simplify it.
For example,
path = &amp;ldquo;/home/&amp;rdquo;, =&amp;gt; &amp;ldquo;/home&amp;rdquo;
path = &amp;ldquo;/a/./b/../../c/&amp;rdquo;, =&amp;gt; &amp;ldquo;/c&amp;rdquo;

My Thoughts I will use stack to solve this problem. And there are some conditions that I will push or pop the stack:
 If I get nothing after &amp;ldquo;/&amp;rdquo;, do nothing. If I get &amp;ldquo;pathname/&amp;rdquo;, push &amp;ldquo;pathname/&amp;rdquo; into stack. If I get &amp;ldquo;.</description>
    </item>
    
  </channel>
</rss>