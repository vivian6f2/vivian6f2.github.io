<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Easy on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/easy/</link>
    <description>Recent content in Easy on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/easy/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Island Perimeter</title>
      <link>https://vivian6f2.github.io/blog/island-perimeter/</link>
      <pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/island-perimeter/</guid>
      <description>Island Perimeter LeetCode #463 
Description You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn&amp;rsquo;t have &amp;ldquo;lakes&amp;rdquo; (water inside that isn&amp;rsquo;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>Path Sum</title>
      <link>https://vivian6f2.github.io/blog/path-sum/</link>
      <pubDate>Sun, 27 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/path-sum/</guid>
      <description>Path Sum LeetCode #112 
Description Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.
For example:
Given the below binary tree and sum = 22,
 5 / \ 4 8 / / \ 11 13 4 / \ \ 7 2 1  return true, as there exist a root-to-leaf path 5-&amp;gt;4-&amp;gt;11-&amp;gt;2 which sum is 22.</description>
    </item>
    
    <item>
      <title>Path Sum III</title>
      <link>https://vivian6f2.github.io/blog/path-sum-iii/</link>
      <pubDate>Sun, 27 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/path-sum-iii/</guid>
      <description>Path Sum III LeetCode #437 
Description You are given a binary tree in which each node contains an integer value.
Find the number of paths that sum to a given value.
The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).
The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</description>
    </item>
    
    <item>
      <title>Moving Average from Data Stream</title>
      <link>https://vivian6f2.github.io/blog/moving-average-from-data-stream/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/moving-average-from-data-stream/</guid>
      <description>Moving Average from Data Stream LeetCode #346 
Description Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window.
For example,
MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3  
My Thoughts For this question, because it is a data stream problem, I would like to do it with queue to make it first-in-first-out.</description>
    </item>
    
    <item>
      <title>Convert Sorted Array to Binary Search Tree</title>
      <link>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/convert-sorted-array-to-binary-search-tree/</guid>
      <description>Convert Sorted Array to Binary Search Tree LeetCode #108 
Description Given an array where elements are sorted in ascending order, convert it to a height balanced BST. 
My Thoughts I like to do tree problem recursively if I can. And for this problem, I know I can do it recursively by dividing a big problem into two small problems until I can solve the question.
Because I have to convert array to a height balanced BST, I think that I have to divide the array in the middle everytime.</description>
    </item>
    
    <item>
      <title>Merge Two Binary Trees</title>
      <link>https://vivian6f2.github.io/blog/merge-two-binary-trees/</link>
      <pubDate>Wed, 09 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/merge-two-binary-trees/</guid>
      <description>Merge Two Binary Trees LeetCode #617 
Description Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.
You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node.</description>
    </item>
    
  </channel>
</rss>