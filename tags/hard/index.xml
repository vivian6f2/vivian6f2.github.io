<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Hard on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/hard/</link>
    <description>Recent content in Hard on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 11 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/hard/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Word Abbreviation</title>
      <link>https://vivian6f2.github.io/blog/word-abbreviation/</link>
      <pubDate>Mon, 11 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/word-abbreviation/</guid>
      <description>Word Abbreviation LeetCode #527 
Description Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below.
 Begin with the first character and then the number of characters abbreviated, which followed by the last character. If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-postorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-postorder-traversal/</guid>
      <description>Binary Tree Postorder Traversal LeetCode #145 
Description Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree {1,#,2,3},
return [3,2,1].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Inorder Traversal and Binary Tree Preorder Traversal.
Postorder = left child, right child, current node.
At first it is hard to figure out how to do it.</description>
    </item>
    
    <item>
      <title>Closest Binary Search Tree Value II</title>
      <link>https://vivian6f2.github.io/blog/closest-binary-search-tree-value-ii/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/closest-binary-search-tree-value-ii/</guid>
      <description>Closest Binary Search Tree Value II LeetCode #272 
Description Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.
Note:
 Given target value is a floating point. You may assume k is always valid, that is: k â‰¤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target.</description>
    </item>
    
    <item>
      <title>Largest Rectangle in Histogram</title>
      <link>https://vivian6f2.github.io/blog/largest-rectangle-in-histogram/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/largest-rectangle-in-histogram/</guid>
      <description>Largest Rectangle in Histogram LeetCode #84 
Description Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
For example,
Given heights = [2,1,5,6,2,3],
return 10.

My Thoughts At first, this question let me think about Trapping Rain Water. I think I can also do it with two pointers, left and right. And just find pairs of left and right that between them, all the value is not less than left and right.</description>
    </item>
    
    <item>
      <title>Reverse Nodes in k-Group</title>
      <link>https://vivian6f2.github.io/blog/reverse-nodes-in-k-group/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/reverse-nodes-in-k-group/</guid>
      <description>Reverse Nodes in k-Group LeetCode #25 
Description Given a linked list, reverse the nodes of a linked list k at a time and return its modified list.
k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes in the end should remain as it is.
You may not alter the values in the nodes, only nodes itself may be changed.</description>
    </item>
    
    <item>
      <title>Trapping Rain Water</title>
      <link>https://vivian6f2.github.io/blog/trapping-rain-water/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/trapping-rain-water/</guid>
      <description>Trapping Rain Water LeetCode #42 
Description Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.
For example,  Given [0,1,0,2,1,0,1,3,2,1,2,1], return 6.
My Thoughts I would like to do this problem with two pointers, one points to left wall and another to right wall. If I can find out left and right wall for every part that can trap water, then I can easily compute total water I can get.</description>
    </item>
    
  </channel>
</rss>