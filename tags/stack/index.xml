<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stack on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/stack/</link>
    <description>Recent content in Stack on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Sep 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Island Perimeter</title>
      <link>https://vivian6f2.github.io/blog/island-perimeter/</link>
      <pubDate>Mon, 04 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/island-perimeter/</guid>
      <description>Island Perimeter LeetCode #463 
Description You are given a map in form of a two-dimensional integer grid where 1 represents land and 0 represents water. Grid cells are connected horizontally/vertically (not diagonally). The grid is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells). The island doesn&amp;rsquo;t have &amp;ldquo;lakes&amp;rdquo; (water inside that isn&amp;rsquo;t connected to the water around the island). One cell is a square with side length 1.</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-inorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-inorder-traversal/</guid>
      <description>Binary Tree Inorder Traversal LeetCode #94 
Description Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree [1,null,2,3],
return [1,3,2].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Preorder Traversal and Binary Tree Postorder Traversal.
Inorder = left child, current node, right child.
The inorder one is similar to preorder one.</description>
    </item>
    
    <item>
      <title>Binary Tree Postorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-postorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-postorder-traversal/</guid>
      <description>Binary Tree Postorder Traversal LeetCode #145 
Description Given a binary tree, return the postorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree {1,#,2,3},
return [3,2,1].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Inorder Traversal and Binary Tree Preorder Traversal.
Postorder = left child, right child, current node.
At first it is hard to figure out how to do it.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-preorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-preorder-traversal/</guid>
      <description>Binary Tree Preorder Traversal LeetCode #144 
Description Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree {1,#,2,3},
return [1,2,3].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Inorder Traversal and Binary Tree Postorder Traversal.
It is always easy to do tree problem recursively. If I want to do it iteratively, then I need a stack to save all tree nodes that I will need later.</description>
    </item>
    
    <item>
      <title>Closest Binary Search Tree Value II</title>
      <link>https://vivian6f2.github.io/blog/closest-binary-search-tree-value-ii/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/closest-binary-search-tree-value-ii/</guid>
      <description>Closest Binary Search Tree Value II LeetCode #272 
Description Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.
Note:
 Given target value is a floating point. You may assume k is always valid, that is: k ≤ total nodes. You are guaranteed to have only one unique set of k values in the BST that are closest to the target.</description>
    </item>
    
    <item>
      <title>Remove K Digits</title>
      <link>https://vivian6f2.github.io/blog/remove-k-digits/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/remove-k-digits/</guid>
      <description>Remove K Digits LeetCode #402 
Description Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note:
 The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.  Example 1:
Input: num = &amp;quot;1432219&amp;quot;, k = 3 Output: &amp;quot;1219&amp;quot; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title>Largest Rectangle in Histogram</title>
      <link>https://vivian6f2.github.io/blog/largest-rectangle-in-histogram/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/largest-rectangle-in-histogram/</guid>
      <description>Largest Rectangle in Histogram LeetCode #84 
Description Given n non-negative integers representing the histogram&amp;rsquo;s bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.
For example,
Given heights = [2,1,5,6,2,3],
return 10.

My Thoughts At first, this question let me think about Trapping Rain Water. I think I can also do it with two pointers, left and right. And just find pairs of left and right that between them, all the value is not less than left and right.</description>
    </item>
    
    <item>
      <title>Simplify Path</title>
      <link>https://vivian6f2.github.io/blog/simplify-path/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/simplify-path/</guid>
      <description>Simplify Path LeetCode #71 
Description Given an absolute path for a file (Unix-style), simplify it.
For example,
path = &amp;ldquo;/home/&amp;rdquo;, =&amp;gt; &amp;ldquo;/home&amp;rdquo;
path = &amp;ldquo;/a/./b/../../c/&amp;rdquo;, =&amp;gt; &amp;ldquo;/c&amp;rdquo;

My Thoughts I will use stack to solve this problem. And there are some conditions that I will push or pop the stack:
 If I get nothing after &amp;ldquo;/&amp;rdquo;, do nothing. If I get &amp;ldquo;pathname/&amp;rdquo;, push &amp;ldquo;pathname/&amp;rdquo; into stack. If I get &amp;ldquo;.</description>
    </item>
    
    <item>
      <title>How Many Combination Results</title>
      <link>https://vivian6f2.github.io/blog/how-many-combination-results/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/how-many-combination-results/</guid>
      <description>How Many Combination Results 
Description Given an array of numbers, put [+, -, *, /] randomly between every two numbers. Compute and list all possible results.

My Thoughts I think I can do it both iteratively and recursively. If I want to do it iteratively, then I need a stack or a queue. While I do it recursively, then I just have to push result into array when I finish computing last number.</description>
    </item>
    
  </channel>
</rss>