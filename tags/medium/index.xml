<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Medium on Ting-Hsuan Lin</title>
    <link>https://vivian6f2.github.io/tags/medium/</link>
    <description>Recent content in Medium on Ting-Hsuan Lin</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 13 Aug 2017 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://vivian6f2.github.io/tags/medium/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>3 Sum Smaller</title>
      <link>https://vivian6f2.github.io/blog/3-sum-smaller/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/3-sum-smaller/</guid>
      <description>3 Sum Smaller LeetCode #259 
Description Given an array of n integers nums and a target, find the number of index triplets i, j, k with 0 &amp;lt;= i &amp;lt; j &amp;lt; k &amp;lt; n that satisfy the condition nums[i] + nums[j] + nums[k] &amp;lt; target.
For example, given nums = [-2, 0, 1, 3], and target = 2.
Return 2. Because there are two triplets which sums are less than 2:</description>
    </item>
    
    <item>
      <title>Binary Tree Inorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-inorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-inorder-traversal/</guid>
      <description>Binary Tree Inorder Traversal LeetCode #94 
Description Given a binary tree, return the inorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree [1,null,2,3],
return [1,3,2].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Preorder Traversal and Binary Tree Postorder Traversal.
Inorder = left child, current node, right child.
The inorder one is similar to preorder one.</description>
    </item>
    
    <item>
      <title>Binary Tree Preorder Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-preorder-traversal/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-preorder-traversal/</guid>
      <description>Binary Tree Preorder Traversal LeetCode #144 
Description Given a binary tree, return the preorder traversal of its nodes&amp;rsquo; values.
For example:
Given binary tree {1,#,2,3},
return [1,2,3].
Note: Recursive solution is trivial, could you do it iteratively?

My Thoughts This is a similar question to Binary Tree Inorder Traversal and Binary Tree Postorder Traversal.
It is always easy to do tree problem recursively. If I want to do it iteratively, then I need a stack to save all tree nodes that I will need later.</description>
    </item>
    
    <item>
      <title>Copy List with Random Pointer</title>
      <link>https://vivian6f2.github.io/blog/copy-list-with-random-pointer/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/copy-list-with-random-pointer/</guid>
      <description>Copy List with Random Pointer LeetCode #138 
Description A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.
Return a deep copy of the list.

My Thoughts Because there is a random pointer for every node, I think it is impossible to copy list with one loop. And I also need to save every node first becuase there is a random pointer, and I am not sure where it is linked to.</description>
    </item>
    
    <item>
      <title>Linked List Cycle II</title>
      <link>https://vivian6f2.github.io/blog/linked-list-cycle-ii/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/linked-list-cycle-ii/</guid>
      <description>Linked List Cycle II LeetCode #142 
Description Given a linked list, return the node where the cycle begins. If there is no cycle, return null.
Note: Do not modify the linked list.
Follow up: Can you solve it without using extra space?

My Thoughts To check if I have already been to a node, I can add a hash map to store every node I gone through. However, if I use a hash map, I need O(n) extra space.</description>
    </item>
    
    <item>
      <title>Remove K Digits</title>
      <link>https://vivian6f2.github.io/blog/remove-k-digits/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/remove-k-digits/</guid>
      <description>Remove K Digits LeetCode #402 
Description Given a non-negative integer num represented as a string, remove k digits from the number so that the new number is the smallest possible.
Note:
 The length of num is less than 10002 and will be ≥ k. The given num does not contain any leading zero.  Example 1:
Input: num = &amp;quot;1432219&amp;quot;, k = 3 Output: &amp;quot;1219&amp;quot; Explanation: Remove the three digits 4, 3, and 2 to form the new number 1219 which is the smallest.</description>
    </item>
    
    <item>
      <title>Sort Transformed Array</title>
      <link>https://vivian6f2.github.io/blog/sort-transformed-array/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/sort-transformed-array/</guid>
      <description>Sort Transformed Array LeetCode #360 
Description Given a sorted array of integers nums and integer values a, b and c. Apply a function of the form f(x) = ax^2 + bx + c to each element x in the array.
The returned array must be in sorted order.
Expected time complexity: O(n)
Example:
nums = [-4, -2, 2, 4], a = 1, b = 3, c = 5,</description>
    </item>
    
    <item>
      <title>Top K Frequent Elements</title>
      <link>https://vivian6f2.github.io/blog/top-k-frequent-elements/</link>
      <pubDate>Sun, 13 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/top-k-frequent-elements/</guid>
      <description>Top K Frequent Elements LeetCode #347 
Description Given a non-empty array of integers, return the k most frequent elements.
For example,
Given [1,1,1,2,2,3] and k = 2, return [1,2].
Note:
 You may assume k is always valid, 1 ? k ? number of unique elements. Your algorithm&amp;rsquo;s time complexity must be better than O(n log n), where n is the array&amp;rsquo;s size.  
My Thoughts I can divide this question into two parts:</description>
    </item>
    
    <item>
      <title>4 Sum</title>
      <link>https://vivian6f2.github.io/blog/4-sum/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/4-sum/</guid>
      <description>4 Sum LeetCode #18 
Description Given an array S of n integers, are there elements a, b, c, and d in S such that a + b + c + d = target? Find all unique quadruplets in the array which gives the sum of target.
Note: The solution set must not contain duplicate quadruplets.
For example, given array S = [1, 0, -1, 0, -2, 2], and target = 0.</description>
    </item>
    
    <item>
      <title>Binary Tree Level Order Traversal</title>
      <link>https://vivian6f2.github.io/blog/binary-tree-level-order-traversal/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/binary-tree-level-order-traversal/</guid>
      <description>Binary Tree Level Order Traversal LeetCode #102 
Description Given a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (ie, from left to right, level by level).
For example:
Given binary tree [3,9,20,null,null,15,7],
return its level order traversal as:
[ [3], [9,20], [15,7] ]  
My Thoughts I will try to do this recursively. And I would create a 2-D array with the first dimension for level and second dimension for value.</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://vivian6f2.github.io/blog/container-with-most-water/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/container-with-most-water/</guid>
      <description>Container With Most Water LeetCode #11 
Description Given n non-negative integers a1, a2, &amp;hellip;, an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.
Note: You may not slant the container and n is at least 2.</description>
    </item>
    
    <item>
      <title>Simplify Path</title>
      <link>https://vivian6f2.github.io/blog/simplify-path/</link>
      <pubDate>Sat, 12 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/simplify-path/</guid>
      <description>Simplify Path LeetCode #71 
Description Given an absolute path for a file (Unix-style), simplify it.
For example,
path = &amp;ldquo;/home/&amp;rdquo;, =&amp;gt; &amp;ldquo;/home&amp;rdquo;
path = &amp;ldquo;/a/./b/../../c/&amp;rdquo;, =&amp;gt; &amp;ldquo;/c&amp;rdquo;

My Thoughts I will use stack to solve this problem. And there are some conditions that I will push or pop the stack:
 If I get nothing after &amp;ldquo;/&amp;rdquo;, do nothing. If I get &amp;ldquo;pathname/&amp;rdquo;, push &amp;ldquo;pathname/&amp;rdquo; into stack. If I get &amp;ldquo;.</description>
    </item>
    
    <item>
      <title>3 Sum</title>
      <link>https://vivian6f2.github.io/blog/3-sum/</link>
      <pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/3-sum/</guid>
      <description>3 Sum LeetCode #15 
Description Given an array S of n integers, are there elements a, b, c in S such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.

My Thoughts Create a helper function twoSum(nums, target), to find if there are any two elements A and B in nums, A + B = target.</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>https://vivian6f2.github.io/blog/longest-substring-without-repeating-characters/</link>
      <pubDate>Tue, 08 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/longest-substring-without-repeating-characters/</guid>
      <description>Longest Substring Without Repeating Characters LeetCode #3 
Description Given a string, find the length of the longest substring without repeating characters.
Examples:
Given &amp;ldquo;abcabcbb&amp;rdquo;, the answer is &amp;ldquo;abc&amp;rdquo;, which the length is 3.
Given &amp;ldquo;bbbbb&amp;rdquo;, the answer is &amp;ldquo;b&amp;rdquo;, with the length of 1.
Given &amp;ldquo;pwwkew&amp;rdquo;, the answer is &amp;ldquo;wke&amp;rdquo;, with the length of 3. Note that the answer must be a substring, &amp;ldquo;pwke&amp;rdquo; is a subsequence and not a substring.</description>
    </item>
    
    <item>
      <title>Reorder List</title>
      <link>https://vivian6f2.github.io/blog/reorder-list/</link>
      <pubDate>Mon, 07 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>https://vivian6f2.github.io/blog/reorder-list/</guid>
      <description>Reorder List LeetCode #143 
Description Given a singly linked list L: L0?L1?…?Ln-1?Ln, reorder it to: L0?Ln?L1?Ln-1?L2?Ln-2?…
You must do this in-place without altering the nodes&amp;rsquo; values.
For example, Given {1,2,3,4}, reorder it to {1,4,2,3}. 
My Thoughts I will divide this question into some smaller questions:
 Find the middle of the linked list. Just use two pointers, slow and fast. Slow pointer takes one step everytime while fast pointer takes two step.</description>
    </item>
    
  </channel>
</rss>